'use strict';
var FS = require('fs');
var Inherits = require('util').inherits;
var Converter = require('api-spec-converter');
var Types = Converter.Types;
var XMLParser = require('xml2js').parseString;

var Kaltura = module.exports = function() {
  Kaltura.super_.apply(this, arguments);
  this.type = 'kaltura';
  this.converters = {
    swagger_2: function(kaltura, callback) {
      var swagger = {swagger: '2.0'};
      swagger.host = 'www.kaltura.com';
      swagger.schemes = ['http', 'https'];
      swagger.basePath = '/api_v3';
      swagger.info = {title: 'Kaltura', description: 'The Kaltura API'};
      swagger.info.version = kaltura.spec.$.apiVersion;
      swagger.securityDefinitions = {
        "ks": {
          in: 'query',
          name: 'ks',
          type: 'apiKey',
          description: 'A session ID generated by calling /service/session/action/start',
        }
      }
      var services = kaltura.spec.services[0].service;
      var enums = kaltura.spec.enums[0].enum;
      enums = convertEnums(enums);
      var classes = kaltura.spec.classes[0].class;
      swagger.definitions = convertClasses(classes, enums);
      swagger.paths = convertServices(services, enums, swagger.definitions);
      swagger.tags = [];
      services.forEach(function(s) {swagger.tags.push({
        name: s.$.name,
        description: s.$.description,
      })})
      swagger.tags = swagger.tags.sort(function(t1, t2) {
        return t1.name > t2.name ? 1 : -1;
      })
      callback(null, swagger);
    }
  }
};
Types['kaltura'] = Kaltura;
Inherits(Kaltura, Converter.BaseType);

Kaltura.prototype.formatName = 'kaltura';
Kaltura.prototype.supportedVersions = ['1.0'];
Kaltura.prototype.getFormatVersion = function () {
  return '1.0';
}

Kaltura.prototype.parsers = [function(string, cb) {
  XMLParser(string, function(err, parsed) {
    cb(err, parsed ? parsed.xml : null);
  })
}];

Kaltura.prototype.checkFormat = function (spec) {
  return true;
}

var convertEnums = function(enums) {
  var ret = {};
  enums.forEach(function(enm) {
    ret[enm.$.name] = (enm.const || []).map(function(c) {
      return {name: c.$.name, value: c.$.value}
    })
  })
  return ret;
}

var convertClasses = function(classes, enums) {
  var definitions = {KalturaObjectBase: {}};
  classes.forEach(function(cls) {
    var base = cls.$.base;
    var def = definitions[cls.$.name] = {};
    if (base) def.allOf = [{$ref: '#/definitions/' + base}];
    if (cls.$.abstract) def['x-abstract'] = true;
    def.description = cls.$.description;
    def.properties = {};
    var props = cls.property || [];
    props.forEach(function(prop) {
      var swaggerProp = def.properties[prop.$.name] = {};
      if (prop.$.type.indexOf('Kaltura') === 0) {
        swaggerProp.$ref = '#/definitions/' + prop.$.type;
        return;
      } else if (prop.$.arrayType && prop.$.arrayType.indexOf('Kaltura') === 0) {
        swaggerProp.type = 'array';
        swaggerProp.items = {$ref: '#/definitions/' + prop.$.arrayType};
        return;
      }
      if (prop.$.readOnly && prop.$.readOnly !== '0') {
        swaggerProp.readOnly = true;
      }
      swaggerProp.description = prop.$.description || undefined;
      if (swaggerProp.description) swaggerProp.description = swaggerProp.description.replace(/\n\s*\t\s*$/g, '').trim()
      swaggerProp.type = convertType(prop.$.type);
      if (prop.$.enumType) {
        var enm = enums[prop.$.enumType];
        var allVals = enm.map(e => e.value);
        enm = enm.filter(e => allVals.indexOf(e.value) === allVals.lastIndexOf(e.value));
        swaggerProp.enum = enm.map(function(e) {
          return swaggerProp.type === 'integer' ? parseInt(e.value) : e.value;
        })
        swaggerProp['x-enumLabels'] = enm.map(function(e) {
          return e.name;
        })
      }
    })
  });
  return definitions;
}

var convertServices = function(services, enums, definitions) {
  var paths = {};
  services.forEach(function(service) {
    var actions = service.action;
    actions.forEach(function(action) {
      var path = paths['/service/' + service.$.id + '/action/' + action.$.name] = {};
      path = path.get = {};
      path.description = action.$.description;
      path.tags = [service.$.name];
      path.operationId = service.$.name + '.' + action.$.name;
      path.parameters = [{
        name: 'format',
        enum: [1, 2, 3],
        'x-enumLabels': ['JSON', 'XML', 'PHP'],
        description: 'The format of the response',
        in: 'query',
        type: 'integer',
      }];
      var parameters = action.param || [];
      parameters.forEach(function(param) {
        if (param.$.type.indexOf('Kaltura') === 0) {
          path.parameters = path.parameters.concat(getExpandedQueryParameters(param, enums, definitions))
          return;
        } else if (param.$.type === "array" || param.$.type === "file") {
          return;
        }
        var newParam = {
          name: param.$.name,
          in: 'query',
          description: param.$.description,
          type: convertType(param.$.type),
          required: param.optional === 1,
        };
        var enumVals = enums[param.$.enumType];
        if (enumVals) {
          if (newParam.description) newParam.description += '\n\n';
          var allVals = enumVals.map(e => e.value);
          enumVals = enumVals.filter(e => allVals.indexOf(e.value) === allVals.lastIndexOf(e.value));
          newParam.enum = enumVals.map(e => e.value);
          newParam['x-enumLabels'] = enumVals.map(function(e) {return e.name})
        }
        path.parameters.push(newParam)
      });
      path.responses = {
        '200': {
          description: 'Success',
        }
      }
      var result = action.result[0];
      if (result) {
        var resultType = result.$.type;
        if (resultType.indexOf('Kaltura') === 0) {
          path.responses['200'].schema = {'$ref': '#/definitions/' + result.$.type}
        }
      }
    });
  });
  return paths;
}

var getExpandedQueryParameters = function(param, enums, definitions) {
  function getSubclasses(defName) {
    return Object.keys(definitions).filter(function(label) {
      var def = definitions[label];
      var inherits = (def.allOf || []).filter(function(i) {
        return i.$ref === '#/definitions/' + defName;
      })
      return inherits.length;
    })
  }

  var params = [];
  var addParams = function(defName, baseName, cond, shallow) {
    baseName = baseName || param.$.name;
    if (baseName.split(/\[/).length > 4) return;
    var def = definitions[defName];
    if (!def) throw new Error("Definition " + defName + " not found")

    var subclasses = getSubclasses(defName);
    if (!shallow && subclasses.length) {
      var paramName = baseName + '[objectType]';
      params.push({
        name: paramName,
        in: 'query',
        enum: subclasses,
        type: 'string',
      })
      subclasses.forEach(function(subName) {
        addParams(subName, baseName, {name: paramName, value: [subName]}, true);
      })
    }

    var props = def.properties;
    for (var prop in props) {
      var propDef = props[prop];
      if (propDef.readOnly) continue;
      if (propDef.$ref) {
        var subDef = propDef.$ref.match(/definitions\/(.*)$/)[1];
        addParams(subDef, baseName + '[' + prop + ']', cond, false)
        return;
      }
      var newParam = {
        type: propDef.type,
        in: 'query',
        name: baseName + '[' + prop + ']',
        enum: propDef.enum,
        'x-enumLabels': propDef['x-enumLabels'],
        description: propDef.description,
      };
      if (newParam.type === 'array') continue;
      var oldParam = params.filter(p => p.name === newParam.name)[0];
      if (oldParam) {
        oldParam['x-showCondition'].value = oldParam['x-showCondition'].value.concat(cond.value)
      } else {
        if (cond) newParam['x-showCondition'] = cond;
        params.push(newParam);
      }
    }
    if (!shallow) {
      (def.allOf || []).forEach(function(base) {
        addParams(base.$ref.substring('#/definitions/'.length), baseName, cond, true);
      })
    }
  }
  addParams(param.$.type);
  return params;
}

var convertType = function(type) {
  if (type === "bool") return "boolean";
  if (type === "array") return "array";
  if (type === "int" || type === "bigint") return "integer";
  if (type === "float") return "number";
  if (type === "string") return "string";
  if (type === "map") return "object";
  throw new Error("Unknown type:" + type);
}
